#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass extarticle
\begin_preamble
\usepackage{listings}
\usepackage{xcolor}
\usepackage{minted}

\lstset{
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green!50!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    frame=single,
    breaklines=true
}

% Define ARM Cortex-M colors
\definecolor{armblue}{RGB}{0,82,147}
\definecolor{armgreen}{RGB}{0,128,0}
\definecolor{armred}{RGB}{200,0,0}
\definecolor{armpurple}{RGB}{128,0,128}
\definecolor{armgray}{RGB}{100,100,100}
\definecolor{armcomment}{RGB}{0,128,128}
\definecolor{armbackground}{RGB}{248,248,248}
\definecolor{armframecolor}{RGB}{200,200,200}

% Main style for code listings
\lstdefinestyle{STM32Style}{
  backgroundcolor=\color{armbackground},
  basicstyle=\ttfamily\footnotesize,
  commentstyle=\color{armcomment}\itshape,
  keywordstyle=\color{armblue}\bfseries,
  stringstyle=\color{armred},
  numberstyle=\tiny\color{armgray},
  numbers=left,
  numbersep=10pt,
  stepnumber=1,
  numberfirstline=true,
  framesep=5pt,
  framerule=0.8pt,
  rulecolor=\color{armframecolor},
  frame=tb,
  captionpos=b,
  breaklines=true,
  breakatwhitespace=true,
  showstringspaces=false,
  tabsize=4,
  upquote=true
}

% Inline code style
\lstdefinestyle{STM32Inline}{
  basicstyle=\ttfamily\small,
  keywordstyle=\color{armblue},
  commentstyle=\color{armcomment}\itshape,
  numbers=none,
  frame=none,
  backgroundcolor=\color{white}
}

\lstset{style=STM32Style}

% Custom commands
\newcommand{\stmasm}[1]{\lstinline[style=STM32Inline]{#1}}
\newcommand{\asmreg}[1]{\textcolor{armred}{\texttt{#1}}}
\newcommand{\asminst}[1]{\textcolor{armblue}{\textbf{\texttt{#1}}}}
\newcommand{\asmdirective}[1]{\textcolor{armpurple}{\textbf{\texttt{#1}}}}
\end_preamble
\use_default_options true
\maintain_unincluded_children no
\language american
\language_package default
\inputencoding utf8
\fontencoding auto
\font_roman "default" "Linux Libertine"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\float_placement class
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "STM32F103 Flash Loader Protocol"
\pdf_author "Ashok Ashwin"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref section
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content true
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Title
STM32F103 Flash Loader Protocol:
 Complete Technical Reference
\end_layout

\begin_layout Author
Ashok Ashwin
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
This document provides a comprehensive technical reference for the STM32F103C8 UART flash loader protocol.
 It covers the embedded bootloader firmware architecture,
 communication protocol mechanics,
 CRC-16 error detection,
 frame structure,
 handshake procedures,
 and the integration of STM32 Hardware Abstraction Layer (HAL),
 flash programming,
 and UART drivers.
 The document targets firmware engineers implementing or extending flash loading capabilities on STM32 microcontrollers.
\end_layout

\begin_layout Subsection
Scope and Architecture Overview
\end_layout

\begin_layout Standard
This flash loader system comprises three main components:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{Bootloader\ Firmware:}$
\end_inset

 Runs on the STM32F103C8 at reset,
 implements UART communication,
 flash control,
 and application validation
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{Flash\ Loading\ Protocol:}$
\end_inset

 Custom XModem-based protocol with CRC-16 error detection operating over UART at 115200 baud
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{Host-Side\ Tools:}$
\end_inset

 Python scripts implementing the protocol client,
 serial communication,
 and application image management
\end_layout

\begin_layout Standard
The integration of these components ensures robust firmware updates even in hostile environments (electrical noise,
 intermittent connections,
 power interruptions).
\end_layout

\begin_layout Section
Core Concepts:
 HAL,
 UART,
 Flash,
 and CRC
\end_layout

\begin_layout Subsection
1.
 Hardware Abstraction Layer (HAL) Architecture
\end_layout

\begin_layout Standard

\series bold
Definition:

\series default
 HAL is the standardized interface layer between firmware and microcontroller hardware.
 STMicroelectronics provides HAL libraries abstracting registers,
 interrupts,
 and timing details.
\end_layout

\begin_layout Subsubsection
Why HAL Matters for Flash Loading
\end_layout

\begin_layout Standard
Rather than manipulating raw registers,
 the bootloader uses HAL functions:
\end_layout

\begin_layout Itemize

\series bold
Portability:

\series default
 Code remains compatible if moving from STM32F1 to STM32H7 or STM32L4
\end_layout

\begin_layout Itemize

\series bold
Abstraction:

\series default
 Details of flash controller timing,
 cache behavior,
 and synchronization are hidden
\end_layout

\begin_layout Itemize

\series bold
Correctness:

\series default
 Critical sequences (e.g.,
 wait states,
 flash unlocking) are pre-tested by STMicroelectronics
\end_layout

\begin_layout Subsubsection
HAL in the Flash Loader
\end_layout

\begin_layout Standard
Key HAL functions used:
\end_layout

\begin_layout Itemize

\series bold
HAL_RCC_*:

\series default
 Clock configuration (HSE 8MHz,
 PLL to 72MHz,
 peripheral clocks)
\end_layout

\begin_layout Itemize

\series bold
HAL_UART_Transmit / Receive:

\series default
 Synchronized UART I/O with timeout
\end_layout

\begin_layout Itemize

\series bold
HAL_FLASH_Unlock / Lock:

\series default
 Enable/disable flash programming mode
\end_layout

\begin_layout Itemize

\series bold
HAL_FLASH_Program:

\series default
 Write 16-bit or 32-bit words
\end_layout

\begin_layout Itemize

\series bold
HAL_FLASHEx_Erase:

\series default
 Erase full pages (1 KB each on STM32F1)
\end_layout

\begin_layout Itemize

\series bold
SystemClock_Config():

\series default
 Initialize clock tree during bootloader startup
\end_layout

\begin_layout Subsubsection
Clock Configuration
\end_layout

\begin_layout Standard
The bootloader initializes:
\end_layout

\begin_layout Itemize
HSE (8 MHz crystal) as primary oscillator
\end_layout

\begin_layout Itemize
PLL with factor 9 (HSE/1 × 9 = 72 MHz core clock)
\end_layout

\begin_layout Itemize
Flash wait states set to 2 (required for 72 MHz operation)
\end_layout

\begin_layout Itemize
AHB,
 APB1,
 APB2 dividers configured for proper peripheral timing
\end_layout

\begin_layout Standard
This 72 MHz clock provides fast flash operations,
 deterministic UART timing,
 and precise timeouts.
\end_layout

\begin_layout Subsection
2.
 UART Communication Layer
\end_layout

\begin_layout Standard

\series bold
Definition:

\series default
 UART (Universal Asynchronous Receiver Transmitter) is a serial communication standard.
 The STM32F103C8 contains multiple UART instances;
 the bootloader uses USART1 (PA9/PA10).
\end_layout

\begin_layout Subsubsection
UART Configuration
\end_layout

\begin_layout Standard
The bootloader configures USART1 as:
\end_layout

\begin_layout Itemize
Baud rate:
 115200 bits/second
\end_layout

\begin_layout Itemize
Data bits:
 8
\end_layout

\begin_layout Itemize
Stop bits:
 1
\end_layout

\begin_layout Itemize
Parity:
 None
\end_layout

\begin_layout Itemize
Flow control:
 None (no RTS/CTS)
\end_layout

\begin_layout Standard
At 115200 baud,
 each bit takes ~8.68 microseconds;
 one byte takes ~87 microseconds;
 one 128-byte XModem frame takes ~11 milliseconds.
\end_layout

\begin_layout Subsubsection
UART Timeout Handling
\end_layout

\begin_layout Standard
The bootloader defines critical timeouts:
\end_layout

\begin_layout Itemize

\series bold
BOOTLOADER_TIMEOUT (5 seconds):

\series default
 If no START command received,
 auto-jump to application
\end_layout

\begin_layout Itemize

\series bold
HEARTBEAT_INTERVAL (500 ms):

\series default
 Send "BOOT" message to inform host of readiness
\end_layout

\begin_layout Itemize

\series bold
UART_TIMEOUT_MS (5 seconds):

\series default
 Per-byte receive timeout during frame transfer
\end_layout

\begin_layout Standard
These timeouts use HAL_GetTick() system timer for millisecond precision.
\end_layout

\begin_layout Subsection
3.
 Flash Memory Organization and Programming
\end_layout

\begin_layout Standard

\series bold
Definition:

\series default
 Flash is non-volatile electrically erasable programmable memory.
 The STM32F103C8 contains 64 KB of flash divided into 1 KB pages.
\end_layout

\begin_layout Subsubsection
STM32F1 Flash Organization
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Total Flash:
 64 KB (0x08000000 - 0x0800FFFF)
\end_layout

\begin_layout Plain Layout

Page Size:
 1 KB (0x400 bytes)
\end_layout

\begin_layout Plain Layout

Number of Pages:
 64
\end_layout

\begin_layout Plain Layout

Page 0 (0x08000000 - 0x080003FF):
 Bootloader
\end_layout

\begin_layout Plain Layout

Pages 1-7 (0x08000400 - 0x08001FFF):
 Bootloader continuation
\end_layout

\begin_layout Plain Layout

Pages 8-63 (0x08002000 - 0x0800FFFF):
 Application area
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Flash Memory Controller (FMC) Registers
\end_layout

\begin_layout Standard
Key registers controlled through HAL:
\end_layout

\begin_layout Itemize

\series bold
FLASH_ACR:

\series default
 Access control register (sets wait states,
 enables prefetch)
\end_layout

\begin_layout Itemize

\series bold
FLASH_KEYR:

\series default
 Key register for unlocking flash programming
\end_layout

\begin_layout Itemize

\series bold
FLASH_CR:

\series default
 Control register (enables erase/program operations)
\end_layout

\begin_layout Itemize

\series bold
FLASH_SR:

\series default
 Status register (indicates busy,
 operation complete,
 errors)
\end_layout

\begin_layout Itemize

\series bold
FLASH_AR:

\series default
 Address register (target address for erase)
\end_layout

\begin_layout Subsubsection
Flash Write and Erase Mechanics
\end_layout

\begin_layout Standard

\series bold
Program (Write) Operation:
\end_layout

\begin_layout Itemize
Flash must be unlocked (HAL_FLASH_Unlock)
\end_layout

\begin_layout Itemize
Data written in 16-bit or 32-bit words (half-word or word aligned)
\end_layout

\begin_layout Itemize
Flash controller autonomously writes and verifies
\end_layout

\begin_layout Itemize
Firmware polls SR register via HAL until BSY=0
\end_layout

\begin_layout Itemize
Takes approximately 10-40 microseconds per word
\end_layout

\begin_layout Standard

\series bold
Erase Operation:
\end_layout

\begin_layout Itemize
Flash must be unlocked
\end_layout

\begin_layout Itemize
Set page address in AR register
\end_layout

\begin_layout Itemize
Set PER (Page Erase) bit in CR register
\end_layout

\begin_layout Itemize
Set STRT (Start) bit to begin erase
\end_layout

\begin_layout Itemize
Firmware polls SR.BSY until complete
\end_layout

\begin_layout Itemize
Takes approximately 20-40 milliseconds per 1 KB page
\end_layout

\begin_layout Subsubsection
Detailed HAL FLASH API Reference
\end_layout

\begin_layout Standard
The STM32 HAL provides high-level functions to abstract flash hardware complexity.
 Here are the critical functions used in the bootloader:
\end_layout

\begin_layout Standard

\series bold
1.
 HAL_FLASH_Unlock()
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void HAL_FLASH_Unlock(void)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Purpose:

\series default
 Unlock flash memory for programming and erase operations.
\end_layout

\begin_layout Standard

\series bold
Details:
\end_layout

\begin_layout Itemize
Flash is locked by default after reset for safety
\end_layout

\begin_layout Itemize
Internally writes magic keys to FLASH_KEYR register in sequence:
\end_layout

\begin_layout Itemize
 First key:
 0x45670123
\end_layout

\begin_layout Itemize
 Second key:
 0xCDEF89AB
\end_layout

\begin_layout Itemize
Sets flash controller to allow erase/program commands
\end_layout

\begin_layout Itemize
Must be called before any flash programming
\end_layout

\begin_layout Standard

\series bold
2.
 HAL_FLASH_Lock()
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void HAL_FLASH_Lock(void)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Purpose:

\series default
 Lock flash memory after programming/erase to prevent accidental writes.
\end_layout

\begin_layout Standard

\series bold
Details:
\end_layout

\begin_layout Itemize
Sets LOCK bit in FLASH_CR register to 1
\end_layout

\begin_layout Itemize
Disables all erase and program operations
\end_layout

\begin_layout Itemize
Provides protection against software bugs
\end_layout

\begin_layout Itemize
Should be called immediately after HAL_FLASH_Program/HAL_FLASHEx_Erase
\end_layout

\begin_layout Itemize
Safe to call even if flash is already locked
\end_layout

\begin_layout Standard

\series bold
3.
 HAL_FLASHEx_Erase()
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

HAL_StatusTypeDef HAL_FLASHEx_Erase(
\end_layout

\begin_layout Plain Layout

    FLASH_EraseInitTypeDef *pEraseInit,
\end_layout

\begin_layout Plain Layout

    uint32_t *PageError)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Purpose:

\series default
 Erase one or more pages of flash memory.
\end_layout

\begin_layout Standard

\series bold
Parameters:
\end_layout

\begin_layout Itemize

\series bold
pEraseInit:

\series default
 Pointer to erase configuration structure
\end_layout

\begin_layout Itemize
 
\series bold
TypeErase:

\series default
 FLASH_TYPEERASE_PAGES (page erase,
 1 KB granularity)
\end_layout

\begin_layout Itemize
 
\series bold
PageAddress:

\series default
 Starting address of first page to erase
\end_layout

\begin_layout Itemize
 
\series bold
NbPages:

\series default
 Number of consecutive pages to erase
\end_layout

\begin_layout Itemize

\series bold
PageError:

\series default
 Output parameter:
 page number where error occurred (if any)
\end_layout

\begin_layout Standard

\series bold
Return value:
\end_layout

\begin_layout Itemize

\series bold
HAL_OK:

\series default
 Erase successful
\end_layout

\begin_layout Itemize

\series bold
HAL_ERROR:

\series default
 Erase failed (flash is locked or other error)
\end_layout

\begin_layout Itemize

\series bold
HAL_TIMEOUT:

\series default
 Erase operation timed out
\end_layout

\begin_layout Standard

\series bold
Bootloader usage example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

FLASH_EraseInitTypeDef erase_init;
\end_layout

\begin_layout Plain Layout

uint32_t page_error = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

erase_init.TypeErase = FLASH_TYPEERASE_PAGES;
\end_layout

\begin_layout Plain Layout

erase_init.PageAddress = 0x08002000;
  /* Application base */
\end_layout

\begin_layout Plain Layout

erase_init.NbPages = 1;
               /* Erase 1 page (1 KB) */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

HAL_FLASH_Unlock();
\end_layout

\begin_layout Plain Layout

status = HAL_FLASHEx_Erase(&erase_init,
 &page_error);
\end_layout

\begin_layout Plain Layout

HAL_FLASH_Lock();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (status != HAL_OK)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    printf("Erase failed
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Important Notes:
\end_layout

\begin_layout Itemize
Erase time:
 ~20-40 ms per page on STM32F103 at 72 MHz
\end_layout

\begin_layout Itemize
Entire page is erased to 0xFFFFFFFF (all 1's)
\end_layout

\begin_layout Itemize
Bootloader pages (0-7) should NEVER be erased by application code
\end_layout

\begin_layout Itemize
After erase,
 page must be written to complete the cycle
\end_layout

\begin_layout Standard

\series bold
4.
 HAL_FLASH_Program()
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

HAL_StatusTypeDef HAL_FLASH_Program(
\end_layout

\begin_layout Plain Layout

    uint32_t TypeProgram,
\end_layout

\begin_layout Plain Layout

    uint32_t Address,
\end_layout

\begin_layout Plain Layout

    uint64_t Data)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Purpose:

\series default
 Write data to flash memory at specified address.
\end_layout

\begin_layout Standard

\series bold
Parameters:
\end_layout

\begin_layout Itemize

\series bold
TypeProgram:

\series default
 FLASH_TYPEPROGRAM_HALFWORD (16-bit) or FLASH_TYPEPROGRAM_WORD (32-bit)
\end_layout

\begin_layout Itemize

\series bold
Address:

\series default
 Flash address where data will be written (must be aligned to word size)
\end_layout

\begin_layout Itemize

\series bold
Data:

\series default
 Data to write (16-bit or 32-bit value)
\end_layout

\begin_layout Standard

\series bold
Return value:
\end_layout

\begin_layout Itemize

\series bold
HAL_OK:

\series default
 Program successful
\end_layout

\begin_layout Itemize

\series bold
HAL_ERROR:

\series default
 Flash not unlocked,
 address misaligned,
 or write error
\end_layout

\begin_layout Itemize

\series bold
HAL_TIMEOUT:

\series default
 Flash operation timed out
\end_layout

\begin_layout Standard

\series bold
Bootloader usage (16-bit writes):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

uint32_t flash_addr = 0x08002000;
  /* Application base */
\end_layout

\begin_layout Plain Layout

uint8_t firmware_data[128];
        /* 128-byte chunk from XModem */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

HAL_FLASH_Unlock();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for (int i = 0;
 i < 128;
 i += 2)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    /* Combine two bytes into 16-bit word (little-endian) */
\end_layout

\begin_layout Plain Layout

    uint16_t word = (uint16_t)firmware_data[i] |
\end_layout

\begin_layout Plain Layout

                   ((uint16_t)firmware_data[i + 1] << 8);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD,
\end_layout

\begin_layout Plain Layout

                              flash_addr + i,
\end_layout

\begin_layout Plain Layout

                              word);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    if (status != HAL_OK)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        HAL_FLASH_Lock();
\end_layout

\begin_layout Plain Layout

        return -1;
  /* Write error */
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

HAL_FLASH_Lock();
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Key Characteristics:
\end_layout

\begin_layout Itemize
Write time:
 ~10-40 microseconds per 16-bit word
\end_layout

\begin_layout Itemize
Can only program 0 bits to 1 bits (not 1 to 0)
\end_layout

\begin_layout Itemize
Page must be erased first before programming
\end_layout

\begin_layout Itemize
STM32F1 supports only 16-bit and 32-bit writes (no 8-bit)
\end_layout

\begin_layout Itemize
Misaligned writes will silently fail or produce undefined behavior
\end_layout

\begin_layout Subsubsection
Complete Flash Write Function from Bootloader
\end_layout

\begin_layout Standard
Here is the complete 
\series bold
flash_write_page()
\series default
 function as implemented in main.c,
 demonstrating proper HAL FLASH API usage:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

static int flash_write_page(uint32_t addr,
 const uint8_t *data,
 uint16_t size)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  uint32_t page_error = 0;
\end_layout

\begin_layout Plain Layout

  FLASH_EraseInitTypeDef erase_init;
\end_layout

\begin_layout Plain Layout

  HAL_StatusTypeDef status;
\end_layout

\begin_layout Plain Layout

  uint16_t i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Validate address range */
\end_layout

\begin_layout Plain Layout

  if (addr < APP_BASE_ADDR || (addr + size) > (BOOT_BASE_ADDR + FLASH_SIZE))
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    return -1;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Validate size is word-aligned */
\end_layout

\begin_layout Plain Layout

  if (size & 1)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    return -1;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Step 1:
 Unlock flash for programming */
\end_layout

\begin_layout Plain Layout

  HAL_FLASH_Unlock();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Step 2:
 Configure erase operation for 1KB page */
\end_layout

\begin_layout Plain Layout

  erase_init.TypeErase = FLASH_TYPEERASE_PAGES;
\end_layout

\begin_layout Plain Layout

  erase_init.PageAddress = addr;
\end_layout

\begin_layout Plain Layout

  erase_init.NbPages = 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Step 3:
 Erase the page */
\end_layout

\begin_layout Plain Layout

  status = HAL_FLASHEx_Erase(&erase_init,
 &page_error);
\end_layout

\begin_layout Plain Layout

  if (status != HAL_OK)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    HAL_FLASH_Lock();
\end_layout

\begin_layout Plain Layout

    return -1;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Step 4:
 Program data as 16-bit words */
\end_layout

\begin_layout Plain Layout

  for (i = 0;
 i < size;
 i += 2)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    uint16_t word = (uint16_t)data[i] | ((uint16_t)data[i + 1] << 8);
\end_layout

\begin_layout Plain Layout

    status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD,
 addr + i,
 word);
\end_layout

\begin_layout Plain Layout

    if (status != HAL_OK)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      HAL_FLASH_Lock();
\end_layout

\begin_layout Plain Layout

      return -1;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Step 5:
 Lock flash after programming */
\end_layout

\begin_layout Plain Layout

  HAL_FLASH_Lock();
\end_layout

\begin_layout Plain Layout

  return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Analysis of the function:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{Address\ Validation:}$
\end_inset

 Ensures write stays within application range (0x08002000 - 0x0800FFFF)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{Size\ Validation:}$
\end_inset

 Checks that size is even (required for 16-bit writes)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{Unlock:}$
\end_inset

 Enables flash programming via HAL_FLASH_Unlock()
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{Erase:}$
\end_inset

 Clears target page to 0xFF via HAL_FLASHEx_Erase()
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{Program:}$
\end_inset

 Writes data in 16-bit words with error checking
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{Lock:}$
\end_inset

 Re-protects flash immediately after write via HAL_FLASH_Lock()
\end_layout

\begin_layout Standard
This page-buffered approach minimizes erase cycles,
 reduces wear on flash,
 and fits within 20 KB RAM.
\end_layout

\begin_layout Subsection
4.
 CRC-16-XMODEM Error Detection
\end_layout

\begin_layout Standard

\series bold
Definition:

\series default
 CRC (Cyclic Redundancy Check) detects transmission errors.
 The bootloader uses CRC-16-XMODEM polynomial 0x1021 for frame validation.
\end_layout

\begin_layout Subsubsection
CRC-16-XMODEM Algorithm
\end_layout

\begin_layout Standard
The CRC-16-XMODEM polynomial is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
G(x)=x^{16}+x^{12}+x^{5}+1
\]

\end_inset


\end_layout

\begin_layout Standard
Algorithm:
\end_layout

\begin_layout Enumerate
Initialize CRC to 0x0000
\end_layout

\begin_layout Enumerate
For each byte in the frame:
\begin_inset Newline newline
\end_inset

XOR byte into high byte of CRC
\begin_inset Newline newline
\end_inset

Shift CRC left by 1 bit,
 8 times
\begin_inset Newline newline
\end_inset

If MSB was 1,
 XOR CRC with 0x1021 after each shift
\end_layout

\begin_layout Enumerate
Final CRC is appended as 16-bit big-endian value
\end_layout

\begin_layout Subsubsection
CRC in Python
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def crc16_xmodem(data):
\end_layout

\begin_layout Plain Layout

    """Calculate XModem CRC-16 (polynomial 0x1021)"""
\end_layout

\begin_layout Plain Layout

    crc = 0
\end_layout

\begin_layout Plain Layout

    for byte in data:
\end_layout

\begin_layout Plain Layout

        crc ^= byte << 8
\end_layout

\begin_layout Plain Layout

        for _ in range(8):
\end_layout

\begin_layout Plain Layout

            crc <<= 1
\end_layout

\begin_layout Plain Layout

            if crc & 0x10000:
\end_layout

\begin_layout Plain Layout

                crc ^= 0x1021
\end_layout

\begin_layout Plain Layout

            crc &= 0xFFFF
\end_layout

\begin_layout Plain Layout

    return crc
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This produces a 16-bit value highly sensitive to any single-bit error.
 The probability of an undetected error is less than 1 in 65536.
\end_layout

\begin_layout Subsubsection
Why CRC-16-XMODEM?
\end_layout

\begin_layout Standard
The XModem standard is well-tested and industry-proven.
 Its 16-bit CRC:
\end_layout

\begin_layout Itemize
Detects all 1-bit and 2-bit errors
\end_layout

\begin_layout Itemize
Detects most burst errors up to 16 bits
\end_layout

\begin_layout Itemize
Is computationally efficient (no large lookup tables)
\end_layout

\begin_layout Itemize
Is implemented identically on microcontroller and host
\end_layout

\begin_layout Section
Foundational Concepts for Flash Loaders
\end_layout

\begin_layout Standard
Before implementing or understanding the flash loader protocol,
 you should be comfortable with these foundational topics.
\end_layout

\begin_layout Subsection
1.
 Serial Communication and UART (Mandatory)
\end_layout

\begin_layout Itemize
Asynchronous communication (no shared clock between sender and receiver)
\end_layout

\begin_layout Itemize
Baud rate:
 Speed in bits per second (115200 for this loader)
\end_layout

\begin_layout Itemize
Frame format:
 Start bit,
 8 data bits,
 1 stop bit (10 bits total per byte)
\end_layout

\begin_layout Itemize
Timeout handling:
 Must handle device disconnection or power loss
\end_layout

\begin_layout Subsection
2.
 Frame-Based Protocols (Mandatory)
\end_layout

\begin_layout Standard
A frame is a discrete message:
 [Header | Data | Trailer].
 The flash loader uses XModem framing with:
\end_layout

\begin_layout Itemize
Clear boundaries (SOH delimiter)
\end_layout

\begin_layout Itemize
Block numbering (detect duplicates and losses)
\end_layout

\begin_layout Itemize
CRC trailer (detect payload corruption)
\end_layout

\begin_layout Subsection
3.
 Flash Memory Organization (Mandatory)
\end_layout

\begin_layout Itemize
STM32F103C8 contains 64 KB flash at 0x08000000 - 0x0800FFFF
\end_layout

\begin_layout Itemize
Page size:
 1 KB (erase granularity)
\end_layout

\begin_layout Itemize
Application starts at page 8 (0x08002000) after 8 KB bootloader
\end_layout

\begin_layout Itemize
Bootloader flash must never be erased by application
\end_layout

\begin_layout Subsection
4.
 Bootloader State Machine (Important)
\end_layout

\begin_layout Standard
The bootloader implements a clear state machine:
\end_layout

\begin_layout Itemize

\series bold
Heartbeat State:

\series default
 Send "BOOT" every 500ms,
 listen for mode
\end_layout

\begin_layout Itemize

\series bold
Transfer State:

\series default
 Receive XModem frames,
 accumulate,
 write flash
\end_layout

\begin_layout Itemize

\series bold
Auto-Jump:

\series default
 Timeout without host response,
 jump to application
\end_layout

\begin_layout Subsection
5.
 Application Validation (Important)
\end_layout

\begin_layout Standard
Before jumping to application,
 bootloader verifies:
\end_layout

\begin_layout Itemize

\series bold
Non-zero initial MSP:

\series default
 If MSP at 0x08002000 is 0x00000000,
 application is invalid
\end_layout

\begin_layout Itemize

\series bold
Valid vector table:

\series default
 First word must point into RAM
\end_layout

\begin_layout Itemize

\series bold
Code present:

\series default
 At least one non-0xFF byte in application region
\end_layout

\begin_layout Section
Flash Loader Protocol Specification
\end_layout

\begin_layout Subsection
Protocol Overview
\end_layout

\begin_layout Standard

\series bold
Name:

\series default
 STM32F103 UART Flash Loader (XModem-CRC variant)
\end_layout

\begin_layout Standard

\series bold
Transport:

\series default
 UART at 115200 baud,
 8 data bits,
 1 stop bit,
 no parity
\end_layout

\begin_layout Standard

\series bold
Physical Interface:

\series default
 USART1 (PA9=TX,
 PA10=RX) on STM32F103C8
\end_layout

\begin_layout Standard

\series bold
Error Detection:

\series default
 CRC-16-XMODEM (polynomial 0x1021)
\end_layout

\begin_layout Standard

\series bold
Frame Size:

\series default
 128-byte data payload + 5-byte header + 2-byte CRC = 135 bytes
\end_layout

\begin_layout Standard

\series bold
Addressing:

\series default
 Application space 0x08002000 - 0x0800FFFF (56 KB)
\end_layout

\begin_layout Subsection
Communication Phases
\end_layout

\begin_layout Subsubsection
Phase 1:
 Bootloader Heartbeat (Discovery)
\end_layout

\begin_layout Standard
Upon power-on or reset,
 bootloader enters heartbeat state:
\end_layout

\begin_layout Enumerate
Initialize clocks (72 MHz via PLL)
\end_layout

\begin_layout Enumerate
Initialize UART1 (115200 baud)
\end_layout

\begin_layout Enumerate
Validate application (check MSP and initial vector)
\end_layout

\begin_layout Enumerate
Start 5-second timeout counter
\end_layout

\begin_layout Enumerate
Send "BOOT<CR><LF>" every 500 milliseconds
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Bootloader → Host:
 "BOOT<CR><LF>" (6 bytes)
\end_layout

\begin_layout Plain Layout

Bootloader → Host:
 "BOOT<CR><LF>" (after 500ms)
\end_layout

\begin_layout Plain Layout

Bootloader → Host:
 ...
 (continues until mode received or timeout)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Timeout Behavior:

\series default
 If no mode command within 5 seconds and application is valid,
 bootloader automatically jumps to application.
 This allows devices to boot without host intervention.
\end_layout

\begin_layout Subsubsection
Phase 2:
 Mode Selection
\end_layout

\begin_layout Standard
Host receives "BOOT" message and sends mode selection:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Host → Bootloader:
 'C' (0x43) - Select CRC-16 mode
\end_layout

\begin_layout Plain Layout

Host → Bootloader:
 'N' (0x4E) - Select checksum mode (legacy)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Upon receiving 'C',
 bootloader exits heartbeat state and begins listening for data frames.
\end_layout

\begin_layout Subsubsection
Phase 3:
 Data Transfer Loop
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Frame Format:
 SOH BlockNum ~BlockNum Data[128] CRC_H CRC_L
\end_layout

\begin_layout Plain Layout

Host → Bootloader:
 135-byte frame
\end_layout

\begin_layout Plain Layout

Bootloader:
 Validate CRC,
 accumulate in RAM buffer
\end_layout

\begin_layout Plain Layout

Bootloader:
 When page full or transfer complete,
 erase and write flash
\end_layout

\begin_layout Plain Layout

Bootloader → Host:
 ACK (0x06) on success or NAK (0x15) on failure
\end_layout

\begin_layout Plain Layout

Host:
 Wait for ACK/NAK before sending next frame
\end_layout

\begin_layout Plain Layout

(Loop continues for each 128-byte block)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Error Recovery:

\series default
 If NAK received,
 host retries the same frame (same block number).
 Bootloader detects duplicate by block number and ignores.
\end_layout

\begin_layout Subsubsection
Phase 4:
 End of Transfer
\end_layout

\begin_layout Standard
After all frames sent:
\end_layout

\begin_layout Enumerate
Host sends EOT (0x04)
\end_layout

\begin_layout Enumerate
Bootloader flushes any remaining buffered data to flash
\end_layout

\begin_layout Enumerate
Bootloader sends final ACK (0x06)
\end_layout

\begin_layout Enumerate
Bootloader validates complete application
\end_layout

\begin_layout Enumerate
Bootloader jumps to application at 0x08002000
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Host → Bootloader:
 EOT (0x04)
\end_layout

\begin_layout Plain Layout

Bootloader:
 Finalize flash write
\end_layout

\begin_layout Plain Layout

Bootloader → Host:
 ACK (0x06)
\end_layout

\begin_layout Plain Layout

Bootloader:
 Jump to application
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Detailed Frame Structure
\end_layout

\begin_layout Subsubsection
XModem Frame Format (CRC-16 Mode)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Offset   Size    Field           Purpose
\end_layout

\begin_layout Plain Layout

-------  ------  ------          --------
\end_layout

\begin_layout Plain Layout

0        1 byte  SOH             0x01 - marks start of frame
\end_layout

\begin_layout Plain Layout

1        1 byte  Block#          Frame counter (1-255,
 wraps)
\end_layout

\begin_layout Plain Layout

2        1 byte  ~Block#         Complement of block# (error check)
\end_layout

\begin_layout Plain Layout

3-130    128     Payload         Application data
\end_layout

\begin_layout Plain Layout

131-132  2       CRC-16          Big-endian CRC over Payload
\end_layout

\begin_layout Plain Layout

Total:
   135 bytes
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
CRC-16 Calculation
\end_layout

\begin_layout Standard
CRC is calculated over the 128-byte Payload only (not SOH,
 block numbers,
 or CRC itself).
\end_layout

\begin_layout Itemize

\series bold
Polynomial:

\series default
 0x1021 (standard XModem)
\end_layout

\begin_layout Itemize

\series bold
Initial value:

\series default
 0x0000
\end_layout

\begin_layout Itemize

\series bold
Byte order:

\series default
 Big-endian (MSB first)
\end_layout

\begin_layout Itemize

\series bold
Output:

\series default
 Appended as CRC_H (MSB at offset 131) then CRC_L (LSB at offset 132)
\end_layout

\begin_layout Subsubsection
Block Number Wraparound
\end_layout

\begin_layout Standard
Block number increments from 1 to 255,
 then wraps to 1.
 Block zero is never used.
 This detects:
\end_layout

\begin_layout Itemize
Duplicate frames (same block number received twice)
\end_layout

\begin_layout Itemize
Lost frames (block number jumps)
\end_layout

\begin_layout Itemize
Out-of-order frames
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Sequence:
 1,
 2,
 3,
 ...,
 254,
 255,
 1,
 2,
 ...
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Control Characters
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Name        Value   Meaning
\end_layout

\begin_layout Plain Layout

----------  ------  --------
\end_layout

\begin_layout Plain Layout

SOH         0x01    Start of Header (frame delimiter)
\end_layout

\begin_layout Plain Layout

ACK         0x06    Acknowledge (success)
\end_layout

\begin_layout Plain Layout

NAK         0x15    Negative Acknowledge (retry)
\end_layout

\begin_layout Plain Layout

CAN         0x18    Cancel (abort transfer)
\end_layout

\begin_layout Plain Layout

EOT         0x04    End of Transmission
\end_layout

\begin_layout Plain Layout

'C'         0x43    Initiate CRC-16 mode
\end_layout

\begin_layout Plain Layout

'N'         0x4E    Initiate checksum mode
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Timeout Specifications
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Context                 Timeout     Purpose
\end_layout

\begin_layout Plain Layout

----------------------  ----------  --------
\end_layout

\begin_layout Plain Layout

Heartbeat               500 ms      Interval between "BOOT" messages
\end_layout

\begin_layout Plain Layout

Bootloader Auto-Jump    5 seconds   Exit bootloader if no host response
\end_layout

\begin_layout Plain Layout

Per-Frame Response      5 seconds   Wait for ACK/NAK after sending frame
\end_layout

\begin_layout Plain Layout

Per-Byte RX             5 seconds   Timeout waiting for a single byte
\end_layout

\begin_layout Plain Layout

Post-EOT                N/A         Bootloader immediately jumps after final ACK
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Memory Organization During Transfer
\end_layout

\begin_layout Standard
Bootloader manages flash write as frames arrive:
\end_layout

\begin_layout Itemize

\series bold
page_buffer[1024]:

\series default
 RAM-based accumulation buffer (one flash page size)
\end_layout

\begin_layout Itemize

\series bold
Buffering strategy:

\series default
 8 frames × 128 bytes = 1024 bytes = 1 complete flash page
\end_layout

\begin_layout Itemize

\series bold
Write timing:

\series default
 When buffer full or EOT received,
 entire page is:
\end_layout

\begin_layout Enumerate
Erased (20-40 ms)
\end_layout

\begin_layout Enumerate
Written as 16-bit words (10-40 µs per word)
\end_layout

\begin_layout Enumerate
Verified by read-back
\end_layout

\begin_layout Standard
This minimizes erase cycles (erase is slow) while staying within 20 KB RAM.
\end_layout

\begin_layout Subsection
Application Launch and Reset Behavior
\end_layout

\begin_layout Subsubsection
Bootloader Startup and System Clock Initialization
\end_layout

\begin_layout Standard
When the STM32F103C8 exits reset,
 the bootloader begins executing at 0x08000000:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int main(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  /* Initialize HAL and system clock */
\end_layout

\begin_layout Plain Layout

  HAL_Init();
\end_layout

\begin_layout Plain Layout

  SystemClock_Config();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Initialize UART (115200 baud for flash loader) */
\end_layout

\begin_layout Plain Layout

  MX_USART1_UART_Init();
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  /* Run flash loader protocol (heartbeat sent in flash_loader_main) */
\end_layout

\begin_layout Plain Layout

  flash_loader_main();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* If we reach here,
 jump to application in flash */
\end_layout

\begin_layout Plain Layout

  jump_to_application();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Should never reach this point */
\end_layout

\begin_layout Plain Layout

  while (1) { }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Key initialization steps:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{HAL\_Init():}$
\end_inset

 Initializes HAL infrastructure (NVIC,
 SysTick timer,
 interrupt priorities)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{SystemClock\_Config():}$
\end_inset

 Configures 72 MHz clock from 8 MHz HSE via PLL
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{MX\_USART1\_UART\_Init():}$
\end_inset

 Configures UART1 (PA9=TX,
 PA10=RX) at 115200 baud
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void SystemClock_Config(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
\end_layout

\begin_layout Plain Layout

  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Enable HSE oscillator (8 MHz crystal) */
\end_layout

\begin_layout Plain Layout

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
\end_layout

\begin_layout Plain Layout

  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
\end_layout

\begin_layout Plain Layout

  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Configure PLL:
 8 MHz * 9 = 72 MHz */
\end_layout

\begin_layout Plain Layout

  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
\end_layout

\begin_layout Plain Layout

  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
\end_layout

\begin_layout Plain Layout

  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  HAL_RCC_OscConfig(&RCC_OscInitStruct);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Configure clock distribution */
\end_layout

\begin_layout Plain Layout

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
\end_layout

\begin_layout Plain Layout

                              | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
\end_layout

\begin_layout Plain Layout

  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
\end_layout

\begin_layout Plain Layout

  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
   /* AHB:
 72 MHz */
\end_layout

\begin_layout Plain Layout

  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
    /* APB1:
 36 MHz */
\end_layout

\begin_layout Plain Layout

  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
    /* APB2:
 72 MHz */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Set flash wait states for 72 MHz (requires 2 wait states) */
\end_layout

\begin_layout Plain Layout

  HAL_RCC_ClockConfig(&RCC_ClkInitStruct,
 FLASH_LATENCY_2);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Clock Configuration Details:
\end_layout

\begin_layout Itemize

\series bold
HSE (High-Speed External):

\series default
 8 MHz crystal oscillator
\end_layout

\begin_layout Itemize

\series bold
PLL multiplication:

\series default
 8 MHz × 9 = 72 MHz system clock
\end_layout

\begin_layout Itemize

\series bold
AHB clock:

\series default
 72 MHz (no divider,
 full speed)
\end_layout

\begin_layout Itemize

\series bold
APB1 clock:

\series default
 36 MHz (÷2,
 required limit is 36 MHz max)
\end_layout

\begin_layout Itemize

\series bold
APB2 clock:

\series default
 72 MHz (full speed,
 used for UART)
\end_layout

\begin_layout Itemize

\series bold
Flash wait states:

\series default
 2 cycles (required at 72 MHz per datasheet)
\end_layout

\begin_layout Subsubsection
Bootloader Reset Behavior
\end_layout

\begin_layout Standard

\series bold
What happens during reset:
\end_layout

\begin_layout Enumerate
Hardware resets all internal state,
 clears RAM
\end_layout

\begin_layout Enumerate
Processor starts in reset handler defined in startup assembly (startup_stm32f103xb.s)
\end_layout

\begin_layout Enumerate
Reset handler initializes stack pointer (MSP) to 0x20005000 (top of 20 KB RAM)
\end_layout

\begin_layout Enumerate
Call SystemInit() to set initial clock configuration
\end_layout

\begin_layout Enumerate
Initialize BSS section (zero-initialized global variables)
\end_layout

\begin_layout Enumerate
Call main()
\end_layout

\begin_layout Standard

\series bold
Critical reset details for flash loader:
\end_layout

\begin_layout Itemize
Flash controller is LOCKED at reset (HAL_FLASH_Unlock must be called)
\end_layout

\begin_layout Itemize
All interrupts are disabled at reset
\end_layout

\begin_layout Itemize
SysTick timer is not running (HAL_Init enables it)
\end_layout

\begin_layout Itemize
All GPIO pins default to floating input
\end_layout

\begin_layout Itemize
UART is not initialized (MX_USART1_UART_Init must be called)
\end_layout

\begin_layout Itemize
Vector table at 0x08000000 (bootloader reset vectors)
\end_layout

\begin_layout Subsubsection
Application Validation Before Jump
\end_layout

\begin_layout Standard
Before jumping to application,
 bootloader validates:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

static int check_application_valid(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  uint32_t app_sp = *(volatile uint32_t *)(APP_BASE_ADDR + 0);
\end_layout

\begin_layout Plain Layout

  uint32_t app_reset = *(volatile uint32_t *)(APP_BASE_ADDR + 4);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  /* Check if stack pointer is in valid RAM range */
\end_layout

\begin_layout Plain Layout

  if (app_sp < RAM_START_ADDR || app_sp > RAM_END_ADDR)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    return 0;
  /* Invalid MSP */
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  /* Check if reset vector is in application flash range */
\end_layout

\begin_layout Plain Layout

  if ((app_reset < APP_BASE_ADDR) || (app_reset > (BOOT_BASE_ADDR + FLASH_SIZE)))
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    return 0;
  /* Invalid reset vector */
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  /* Check if reset vector has Thumb bit set (LSB = 1) */
\end_layout

\begin_layout Plain Layout

  if ((app_reset & 0x1) == 0)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    return 0;
  /* Not Thumb code */
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  return 1;
  /* Application is valid */
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Validation checks explained:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{Stack\ Pointer\ (MSP):}$
\end_inset

 Read from offset 0x08002000.
 Must point into RAM (0x20000000 - 0x20005000)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{Reset\ Vector:}$
\end_inset

 Read from offset 0x08002004.
 Must point into flash (0x08002000 - 0x0800FFFF)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{Thumb\ Bit:}$
\end_inset

 Reset vector LSB must be 1 (Cortex-M3 requires Thumb mode)
\end_layout

\begin_layout Standard
If any check fails,
 bootloader returns to heartbeat state and continues waiting for flash command.
\end_layout

\begin_layout Subsubsection
Bootloader Jump-to-Application Sequence
\end_layout

\begin_layout Standard
When jumping to application,
 bootloader must ensure clean handoff:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

static void jump_to_application(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  typedef void (*app_entry_t)(void);
\end_layout

\begin_layout Plain Layout

  uint32_t app_sp;
\end_layout

\begin_layout Plain Layout

  uint32_t app_reset;
\end_layout

\begin_layout Plain Layout

  app_entry_t app_reset_handler;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Step 1:
 Read application vector table */
\end_layout

\begin_layout Plain Layout

  app_sp = *(volatile uint32_t *)(APP_BASE_ADDR + 0);
\end_layout

\begin_layout Plain Layout

  app_reset = *(volatile uint32_t *)(APP_BASE_ADDR + 4);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Step 2:
 Disable all interrupts before context switch */
\end_layout

\begin_layout Plain Layout

  __disable_irq();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Step 3:
 Stop SysTick timer */
\end_layout

\begin_layout Plain Layout

  SysTick->CTRL = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Step 4:
 Disable all NVIC interrupts and clear pending flags */
\end_layout

\begin_layout Plain Layout

  for (uint32_t i = 0;
 i < 8;
 i++)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    NVIC->ICER[i] = 0xFFFFFFFFU;
  /* Interrupt Clear Enable */
\end_layout

\begin_layout Plain Layout

    NVIC->ICPR[i] = 0xFFFFFFFFU;
  /* Interrupt Clear Pending */
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Step 5:
 Deinitialize HAL peripherals (especially UART) */
\end_layout

\begin_layout Plain Layout

  HAL_UART_DeInit(&huart1);
\end_layout

\begin_layout Plain Layout

  HAL_DeInit();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Step 6:
 Relocate NVIC vector table to application */
\end_layout

\begin_layout Plain Layout

  SCB->VTOR = APP_BASE_ADDR;
  /* Vector table offset register */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Step 7:
 Set application stack pointer */
\end_layout

\begin_layout Plain Layout

  __set_MSP(app_sp);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* Step 8:
 Jump to application reset handler */
\end_layout

\begin_layout Plain Layout

  app_reset_handler = (app_entry_t)app_reset;
\end_layout

\begin_layout Plain Layout

  app_reset_handler();
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  /* Never reached */
\end_layout

\begin_layout Plain Layout

  while (1);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Detailed explanation of each step:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{Read\ Vector\ Table:}$
\end_inset

 Fetch MSP (offset 0) and Reset_Handler (offset 4) from application base
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{Disable\ Interrupts:}$
\end_inset

 CPSID instruction prevents interrupts during transition
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{Stop\ SysTick:}$
\end_inset

 Set SysTick->CTRL to 0 to halt system tick timer
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{Disable\ All\ NVIC\ Interrupts:}$
\end_inset

 Clear all ICER (Interrupt Clear Enable) bits and ICPR (Interrupt Clear Pending) bits
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{HAL\ Deinitialization:}$
\end_inset

 Call HAL_UART_DeInit() to release UART1 (prevents interference),
 call HAL_DeInit() for other HAL cleanup
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{Set\ VTOR:}$
\end_inset

 SCB->VTOR (NVIC Vector Table Offset Register) = 0x08002000 relocates interrupt vector table
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{Set\ MSP:}$
\end_inset

 __set_MSP() instruction sets ARM stack pointer to application's initial MSP
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{Jump\ to\ Code:}$
\end_inset

 Function pointer cast and call executes application reset handler
\end_layout

\begin_layout Standard

\series bold
Why this sequence is critical:
\end_layout

\begin_layout Itemize

\series bold
Disable interrupts first:

\series default
 Prevents IRQ firing while still executing bootloader code
\end_layout

\begin_layout Itemize

\series bold
Stop SysTick:

\series default
 SysTick interrupt fires every 1 ms;
 must be disabled before jump
\end_layout

\begin_layout Itemize

\series bold
Clear NVIC interrupt flags:

\series default
 Bootloader may have pending interrupts that application doesn't expect
\end_layout

\begin_layout Itemize

\series bold
Deinitialize HAL:

\series default
 Stops UART reception/transmission,
 closes GPIO handles
\end_layout

\begin_layout Itemize

\series bold
Set VTOR:

\series default
 Application's interrupt vectors now routed to 0x08002000,
 not bootloader's 0x08000000
\end_layout

\begin_layout Itemize

\series bold
Set MSP last:

\series default
 After VTOR is set,
 we update stack pointer to application's expected value
\end_layout

\begin_layout Itemize

\series bold
Jump last:

\series default
 Final instruction hands control to application code
\end_layout

\begin_layout Standard
After the jump,
 application's reset handler executes with clean state,
 all bootloader code and state left behind.
\end_layout

\begin_layout Section
Host-Side Implementation:
 Python Flash Loader
\end_layout

\begin_layout Standard
The host flash_loader.py script implements the client side of the protocol.
\end_layout

\begin_layout Subsection
High-Level Flow
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

1.
  Open serial port (115200 baud)
\end_layout

\begin_layout Plain Layout

2.
  Wait for "BOOT" message from bootloader
\end_layout

\begin_layout Plain Layout

3.
  Send 'C' to select CRC-16 mode
\end_layout

\begin_layout Plain Layout

4.
  Read firmware binary file
\end_layout

\begin_layout Plain Layout

5.
  Pad to 128-byte blocks (fill with 0xFF)
\end_layout

\begin_layout Plain Layout

6.
  For each 128-byte block:
\end_layout

\begin_layout Plain Layout

    a.
  Construct XModem frame (SOH + BlockNum + ~BlockNum + Data + CRC)
\end_layout

\begin_layout Plain Layout

    b.
  Transmit frame
\end_layout

\begin_layout Plain Layout

    c.
  Wait for ACK/NAK
\end_layout

\begin_layout Plain Layout

    d.
  If NAK:
 retry (up to 3 times)
\end_layout

\begin_layout Plain Layout

7.
  Send EOT (0x04)
\end_layout

\begin_layout Plain Layout

8.
  Wait for final ACK
\end_layout

\begin_layout Plain Layout

9.
  Close serial port
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Key Functions
\end_layout

\begin_layout Subsubsection
crc16_xmodem()
\end_layout

\begin_layout Standard
Computes CRC-16 for frame data (identical algorithm as bootloader):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def crc16_xmodem(data):
\end_layout

\begin_layout Plain Layout

    crc = 0
\end_layout

\begin_layout Plain Layout

    for byte in data:
\end_layout

\begin_layout Plain Layout

        crc ^= byte << 8
\end_layout

\begin_layout Plain Layout

        for _ in range(8):
\end_layout

\begin_layout Plain Layout

            crc <<= 1
\end_layout

\begin_layout Plain Layout

            if crc & 0x10000:
\end_layout

\begin_layout Plain Layout

                crc ^= 0x1021
\end_layout

\begin_layout Plain Layout

            crc &= 0xFFFF
\end_layout

\begin_layout Plain Layout

    return crc
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
send_firmware()
\end_layout

\begin_layout Standard
Main function orchestrating the transfer:
\end_layout

\begin_layout Itemize
Opens serial port with retry
\end_layout

\begin_layout Itemize
Waits for bootloader heartbeat
\end_layout

\begin_layout Itemize
Sends mode selection ('C')
\end_layout

\begin_layout Itemize
Loops through firmware blocks
\end_layout

\begin_layout Itemize
Builds and transmits XModem frames
\end_layout

\begin_layout Itemize
Handles ACK/NAK responses with retry logic (max 3 retries per frame)
\end_layout

\begin_layout Itemize
Sends EOT and waits for final ACK
\end_layout

\begin_layout Subsection
Error Handling and Retries
\end_layout

\begin_layout Standard
Host-side error handling includes:
\end_layout

\begin_layout Itemize

\series bold
Frame Timeout:

\series default
 If no ACK/NAK within 2 seconds,
 retry
\end_layout

\begin_layout Itemize

\series bold
CRC Mismatch NAK:

\series default
 Bootloader sends NAK;
 host retransmits same frame
\end_layout

\begin_layout Itemize

\series bold
Max Retries:

\series default
 After 3 failed attempts,
 abort transfer with error message
\end_layout

\begin_layout Itemize

\series bold
Serial Port Errors:

\series default
 Graceful handling of disconnection
\end_layout

\begin_layout Section
Conclusion and Next Steps
\end_layout

\begin_layout Standard
The STM32F103 UART Flash Loader provides a complete,
 robust solution for firmware updates over UART.
 Key takeaways:
\end_layout

\begin_layout Enumerate

\series bold
Protocol Design:

\series default
 XModem-CRC is industry-standard,
 reliable,
 and simple to implement
\end_layout

\begin_layout Enumerate

\series bold
HAL Integration:

\series default
 Hardware abstraction ensures portability and correctness across STM32 families
\end_layout

\begin_layout Enumerate

\series bold
State Machine:

\series default
 Clear,
 testable bootloader logic with defined phases
\end_layout

\begin_layout Enumerate

\series bold
Error Recovery:

\series default
 Timeouts,
 retries,
 and CRC validation provide robustness against real-world communication failures
\end_layout

\begin_layout Enumerate

\series bold
Hands-On Implementation:

\series default
 Both firmware (C) and host (Python) code provided as complete working references
\end_layout

\begin_layout Standard
Future enhancements could include:
\end_layout

\begin_layout Itemize
Firmware signatures for cryptographic authentication
\end_layout

\begin_layout Itemize
Dual-image OTA (over-the-air) updates with rollback
\end_layout

\begin_layout Itemize
USB DFU alternative transport layer
\end_layout

\begin_layout Itemize
Watchdog-based auto-recovery for stalled updates
\end_layout

\begin_layout Itemize
Bootloader self-update capability
\end_layout

\begin_layout Itemize
Progress indication and transfer resumption
\end_layout

\begin_layout Standard
This document provides a solid foundation for understanding,
 implementing,
 and extending flash loading solutions on STM32 microcontrollers.
 The combination of clear protocol specification,
 detailed HAL layer explanation,
 and working code examples ensures that firmware engineers can confidently deploy reliable firmware update systems in production environments.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section*
Appendix:
 Quick Reference
\end_layout

\begin_layout Subsection*
Bootloader Quick-Start
\end_layout

\begin_layout Enumerate
Connect STM32F103C8 to serial port (PA9/PA10)
\end_layout

\begin_layout Enumerate
Power on device
\end_layout

\begin_layout Enumerate
Observe "BOOT<CR><LF>" message every 500ms
\end_layout

\begin_layout Enumerate
Run:
 python3 flash_loader.py -p /dev/ttyUSB0 -f application.bin
\end_layout

\begin_layout Enumerate
After transfer completes,
 bootloader jumps to application
\end_layout

\begin_layout Subsection*
Hardware Requirements
\end_layout

\begin_layout Itemize
STM32F103C8 (or STM32F103CB for 128 KB variant)
\end_layout

\begin_layout Itemize
USB-to-UART adapter (FTDI,
 CH340,
 etc.)
\end_layout

\begin_layout Itemize
5V power supply
\end_layout

\begin_layout Itemize
UART connections:
 TX → PA9,
 RX → PA10,
 GND → GND
\end_layout

\begin_layout Subsection*
Memory Map Summary
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

0x08000000 - 0x08001FFF:
  Bootloader (8 KB)
\end_layout

\begin_layout Plain Layout

0x08002000 - 0x0800FFFF:
  Application (56 KB)
\end_layout

\begin_layout Plain Layout

0x20000000 - 0x20005000:
  RAM (20 KB)
\end_layout

\begin_layout Plain Layout

Page Buffer @ RAM:
        1 KB for flash write buffering
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Frame Checksum Verification
\end_layout

\begin_layout Standard
Always verify:
\end_layout

\begin_layout Enumerate
Block number consistency (byte 1 = ~byte 2)
\end_layout

\begin_layout Enumerate
CRC-16 match over 128-byte payload (bytes 3-130)
\end_layout

\begin_layout Enumerate
SOH delimiter presence at frame start
\end_layout

\begin_layout Subsection*
Working Example:
 Real Flash Load Session
\end_layout

\begin_layout Standard
Below is a real successful flash loading session from a development board:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ st-flash reset && sleep 1 && cd /home/ashwin/Desktop/Projects/FlashLoader && python3 scripts/simple_flash.py -p /dev/ttyUSB0 -f App1/build/Simple_BootLoader.bin
\end_layout

\begin_layout Plain Layout

st-flash 1.8.0
\end_layout

\begin_layout Plain Layout

2026-02-01T11:13:36 INFO common.c:
 STM32F1xx_MD:
 20 KiB SRAM,
 64 KiB flash in at least 1 KiB pages.
\end_layout

\begin_layout Plain Layout

2026-02-01T11:13:36 INFO common.c:
 NRST is not connected --> using software reset via AIRCR
\end_layout

\begin_layout Plain Layout

2026-02-01T11:13:36 INFO common.c:
 Go to Thumb mode
\end_layout

\begin_layout Plain Layout

Firmware size:
 4432 bytes
\end_layout

\begin_layout Plain Layout

Connected to /dev/ttyUSB0 at 115200 baud
\end_layout

\begin_layout Plain Layout

Waiting for bootloader...
\end_layout

\begin_layout Plain Layout

Bootloader detected.
\end_layout

\begin_layout Plain Layout

Sending START command...
\end_layout

\begin_layout Plain Layout

START acknowledged.
\end_layout

\begin_layout Plain Layout

Starting transfer (554 chunks = 4432 bytes)...
\end_layout

\begin_layout Plain Layout

Chunk     1/554 (    0 bytes):
 OK
\end_layout

\begin_layout Plain Layout

Chunk   129/554 ( 1024 bytes):
 OK
\end_layout

\begin_layout Plain Layout

Chunk   257/554 ( 2048 bytes):
 OK
\end_layout

\begin_layout Plain Layout

Chunk   385/554 ( 3072 bytes):
 OK
\end_layout

\begin_layout Plain Layout

Chunk   513/554 ( 4096 bytes):
 OK
\end_layout

\begin_layout Plain Layout

Chunk   554/554 ( 4424 bytes):
 OK
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

All 554 chunks transferred successfully!
\end_layout

\begin_layout Plain Layout

Sending END command...
\end_layout

\begin_layout Plain Layout

Firmware transfer complete!
\end_layout

\begin_layout Plain Layout

Bootloader will now jump to application at 0x08002000
\end_layout

\begin_layout Plain Layout

Serial port closed.
\end_layout

\begin_layout Plain Layout

Flash loading successful.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Analysis:
\end_layout

\begin_layout Itemize
Device detection:
 STM32F1xx with 20 KiB SRAM and 64 KiB flash
\end_layout

\begin_layout Itemize
UART connection established at 115200 baud
\end_layout

\begin_layout Itemize
Bootloader heartbeat received ("Bootloader detected")
\end_layout

\begin_layout Itemize
Protocol handshake successful (START acknowledged)
\end_layout

\begin_layout Itemize
Firmware size:
 4432 bytes (fits in 56 KB application space)
\end_layout

\begin_layout Itemize
Transfer chunked into 554 blocks with progress indicators at every 128 blocks
\end_layout

\begin_layout Itemize
All chunks acknowledged (ACK received for each frame)
\end_layout

\begin_layout Itemize
Final confirmation:
 Application jump initiated to 0x08002000
\end_layout

\begin_layout Subsection*
Troubleshooting Common Issues
\end_layout

\begin_layout Itemize

\series bold
No "BOOT" message:

\series default
 Check UART wiring and baud rate (115200)
\end_layout

\begin_layout Itemize

\series bold
NAK on every frame:

\series default
 CRC mismatch—
verify CRC algorithm matches
\end_layout

\begin_layout Itemize

\series bold
Application does not start:

\series default
 Verify application linked to 0x08002000;
 check bootloader MSP validation
\end_layout

\begin_layout Itemize

\series bold
Device hangs mid-transfer:

\series default
 Flash write timeout—
check clock configuration and flash wait states
\end_layout

\begin_layout Itemize

\series bold
"BOOT" but no mode response:

\series default
 Try resending 'C' manually;
 timeout is 5 seconds
\end_layout

\end_body
\end_document
